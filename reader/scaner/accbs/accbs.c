/// Подключаем ссылку на библиотеку - файл, где содержатся определения слудующих функций:
#include "accbs.h"

/*
    Смысл, принцып работы: Эта функция принимает указатель на строку и выводит её содержимое на экран:
    Функция "str_print" печатает ЛЮБУЮ строку, а в параметры принимает указатель на строку:
*/
void str_print_str(const char *str)
{
	printf("\nOutput:\n\n```\n%s```\n\n", str);                                       // печать
}

/*
    Смысл, принцып работы: Эта функция принимает указатель на строку и освобождает память, выделенную под эту строку.
    Это важно для предотвращения утечек памяти.
    Функция "str_free" очищает ЛЮБУЮ строку(Вернее выделеную память под неё),
    в параметры принимает указатель на строку:
*/
void str_free_str(char *str)
{
	free(str);                                                                        // освобождение памяти
}

/*
    Смысл, принцып работы: Эта функция проверяет правильность расстановки скобок в строке "str".
    Она использует стек для хранения открывающих скобок и проверяет, что каждая закрывающая скобка соответствует последней открывающей скобке.
    В функцию "str_accbs" передаём содержимое файла:
*/
void str_accbs(const char *str)
{
	/// Создаём стёк длиной, равной длине строки, и переменную "top", которая будет указывать на вершину стёка:
	size_t length = strlen(str);                                                      // узнаём длину поолученной строки
	char *stack = (char *)malloc(length);                                             // создаем стёк для хранения открывающих скобок
	if(stack == NULL) {
		return;                                                                       // возращаем функцию
	}

	int64_t top = -1;                                                                 // инициализируем вершину стёка

	printf("The Text Read:\n\n```\n");                                                // пользовательский текст, так, Для удобства

	for(size_t i = 0; i < length; ++i) {                                              // перебираем всю строку
		printf("%c", str[i]);                                                         // печатаем всё, что успели прочитать
		if(strchr(OPENING_BRACKETS, str[i])) {
			stack[++top] = str[i];
		} else if(strchr(CLOSING_BRACKETS, str[i])) {                                 // проверяем их закрытие
			if(top == -1) {                                                           // проверяем, не пуст ли стёк
				printf("\n```\n\nError Code = %lld\n\n", ERROR);                      // печатаем какой-то текст
				str_free_str(stack);                                                  // освобождаем память

				return;                                                               // возращаем функцию
			}

			char open_brace = stack[top--];                                           // извлекаем верхний элемент из стёка
			if(!str_is_matching_pair(open_brace, str[i])) {                           // проверяем соответствие открывающей и закрывающей скобок
				printf("\n```\n\nError Code = %lld\n\n", ERROR);                      // печатаем какой-то текст
				str_free_str(stack);                                                  // освобождаем память

				return;                                                               // возращаем функцию
			}
		}
	}

	/// Проверяем, пуст ли стёк после обработки всей строки:
	if(top != -1) {                                                                   // проверяем, пуст ли стёк после обработки всей строки
		printf("\n```\n\nError Code = %lld\n\n", ERROR);                              // печатаем какой-то текст
	} else {                                                                          // в противном случаи
		printf("```\n\nAll parentheses are balanced!\n\n");                           // печатаем какой-то текст
	}

	str_free_str(stack);                                                              // освобождаем память
}
